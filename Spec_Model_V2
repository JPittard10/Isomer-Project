# import random
import requests
import numpy as np
import pandas as pd
import scipy.signal as scipy
import scipy.optimize as scipyo
import matplotlib.pyplot as plt
import scipy.optimize as optimize
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split

#----------- Opens Github Raw File -----------#

github_url = "https://raw.githubusercontent.com/JPittard10/Isomer-Project/refs/heads/main/Trimmed%20and%20Bunched%20Spectrums/Calibration_feb_23_HPGE_134428sec_trimmed_bunched_240.txt"

# ----------------- FUNCTIONS ------------------#


def linear_fill(x1,x2,y1,y2,width):
    fill_x = np.linspace(x1, x2, num= width)
    fill_y = np.linspace(y1, y2, num= width)
    return(fill_y)


def peak_remover(array_with_peaks, peaks, left_ips, right_ips):
    temp_array = array_with_peaks.copy()
    left_ips = np.int64(left_ips) - 1
    right_ips = np.int64(right_ips) + 1
    for i in range(len(peaks)):
        ####### linear part includes first 2 peaks #########
        if i > 1:
            temp_array[left_ips[i]:right_ips[i]] = linear_fill(left_ips[i], right_ips[i], temp_array[left_ips[i]], temp_array[right_ips[i]], (right_ips[i]-left_ips[i]))
    return(temp_array)


def exponential_func(x, a, b, c):
    return a * np.exp(b * x) + c


def gaussian(x_range,height,center,width):
    return( height * np.exp(-((x_range-center) ** 2)/(2 * width ** 2)))


def peak_inserter(Energy_bin, left_ips, right_ips, peaks, width, data1_array, width_heights):
    just_peaks = np.zeros(len(Energy_bin))
    peak_counts = data1_array[peaks]
    for i in range(len(peaks)):
        rand_x = random.uniform(-2,2)
        rand_w = np.random.normal(1, 0.3)
        left_end = left_ips[i] + rand_x
        right_end = right_ips[i] + rand_x
        num_points = max(1, int(np.ceil(right_end - left_end)))
        peak_xrange = np.linspace(left_end, right_end, num=num_points)       
        peak_height = peak_counts[i]
        peak_center = peaks[i] + rand_x
        peak_width = (right_end - left_end) * rand_w
        gaussian_values = gaussian(peak_xrange, peak_height, peak_center, peak_width)
        int_indices = np.round(peak_xrange).astype(int)
        np.add.at(just_peaks, int_indices, gaussian_values)
    return just_peaks


# Name: Sir_Peaks_plotalot
# Purpose : plots a line on the spectrum plot where the peak was identified
# Creator : James Pittard - 29 / FEB / 2025
# Function : sir_peaks_printsalot( the array for where peaks want to be identified, name of the plot where the peak lines will be displayed i.e plot1 )

def sir_peaks_plotalot(plot_array, plot_name):
    plot_peaks, _ = scipy.find_peaks(plot_array, prominence = 2.5e4)
    plot_peaks_energy = (0.64844 + 0.27383 * np.array((25 * plot_peaks) - 12.5))+6
    for peak in plot_peaks_energy:
        plot_name.axvline(x = peak, color = 'red', alpha = 0.5)
    return(plot_peaks)


# Name: Sir_Peaks_displayalot
# Purpose : displays the energy of the peaks and their respective counts from greatest to largest count, and prints all of the peaks
#           in order from the left to right side of the array
# Creator : James Pittard - 29 / FEB / 2025
# Function : sir_peaks_displayalot( the array for where peaks want to be identified, the name of the array must start with a " ' " and end with a " ' " )

def sir_peaks_displayalot(plot_array, plot_name):
    plot_peaks, _ = scipy.find_peaks(plot_array, prominence = 2.5e4)
    plot_peaks_energy = (0.64844 + 0.27383 * np.array((25 * plot_peaks) - 12.5))+6
    peak_counts = plot_array[plot_peaks]
    sorted_peaks = np.argsort(peak_counts)[::-1]
    print(f"Sorted Peaks For Plot '{plot_name}'")
    print("Peak Energy (keV) | Counts")
    print("-----------------------------")
    for i in sorted_peaks:
        peak_index = plot_peaks[i]
        formatted_peak_energy = f"{plot_peaks_energy[i]:<17.3f}"
        formatted_counts = f"{plot_array[peak_index]:<10.0f}"
        print(f"{formatted_peak_energy} | {formatted_counts}")
    print("-----------------------------")
    print(f"Peaks For Plot '{plot_name}'")
    print("Peak Energy (keV)")
    for energy in plot_peaks_energy:
        print(f"{energy:<0.3f}")
    print("-----------------------------\n\n")


# Name: plot_func
# Purpose : plot a function
# Creator : James Pittard - 29 / FEB / 2025
# Function : plot_func( x axis data, y axis data, name of the x axis, name of the y axis, title of the plot,
#                      units for the x axis, units for the y axis, color of the plot)

def plot_func(x_axis_data, y_axis_data, x_axis_name, y_axis_name, title_name, x_axis_unit, y_axis_unit, color_type):
    spec_plot = pd.DataFrame({x_axis_name: x_axis_data, y_axis_name: y_axis_data})
    plot = spec_plot.plot(x = x_axis_name, y = y_axis_name, title = title_name,
                          xlabel = x_axis_unit, ylabel = y_axis_unit, color = color_type, figsize = (12,6))
    return(plot)


# -------------- Pulls spectrum out of text file --------------#

response = requests.get(github_url)

data1 = response.text
data1_array = np.array(list(map(int, data1.split())))

bin_array = list(range(1,(len(data1_array)+1)))
Energy_bin = 0.64844 + 0.27383 * np.array((25 * np.array(bin_array)) - 12.5)


#----------- Plots Raw spectrum and peaks -----------#

raw_spec_plot = plot_func(Energy_bin, data1_array, 'Energy', 'Counts', 'Raw Spectrum', 'Energy (keV)', 'Counts', 'blue')
peaks_raw_spec = sir_peaks_plotalot(data1_array, raw_spec_plot)
plt.show()

#------------ rel_height is very important, can be fine tuned more--------#

width, width_heights, left_ips, right_ips = scipy.peak_widths(data1_array, peaks_raw_spec, rel_height=0.046)

#---------peak_remover and exponential fitter require cutting off the
#         linear segment towards the beginning, done manually at the moment--------#

smoothed = peak_remover(data1_array, peaks_raw_spec, left_ips, right_ips)

#--------------Smoothed Spectrum Plot----------------#

smooth_plot = plot_func(Energy_bin, smoothed, 'Energy', 'Counts', 'Spectrum Smoothed with Exponential Fit', 'Energy (keV)', 'Counts', 'blue')


#-----------Exponential Fit Plot-----------#

Energy_bin_fit = Energy_bin[peaks_raw_spec[2]: -1]
smoothed_fit = smoothed[peaks_raw_spec[2]: -1]
# b value estimated by looking at initial point and 400 point
popt, pcov = scipyo.curve_fit(exponential_func, Energy_bin_fit, smoothed_fit, p0=  ((1.25 * 1000000),-0.0045814537,0), maxfev = 100000000)

plt.plot(Energy_bin_fit, exponential_func(Energy_bin_fit, popt[0], popt[1], popt[2]), color='red')

#--------------Linear + Exponential fit -------------#

plt.figure(4)
exp_part = exponential_func(Energy_bin_fit, popt[0], popt[1], popt[2])
lin_part = np.linspace(smoothed[0],smoothed[peaks_raw_spec[1]], num = peaks_raw_spec[1]+6)
model_true = np.concatenate((lin_part, exp_part))
plt.figure(5)

#-----------Adding peaks into simulation-----------------#

just_peaks = peak_inserter(model_true, left_ips, right_ips, peaks_raw_spec, width, data1_array, width_heights)

alone_peaks_plot = plot_func(Energy_bin, just_peaks, 'Energy', 'Counts', 'Just Peaks Plot', 'Energy (keV)', 'Counts', 'blue')

#-----------Adding peaks to smoothed plot-----------------#

model = np.maximum(just_peaks, smoothed)

Base_model_plot = plot_func(Energy_bin, model, 'Energy', 'Counts', 'Base Model', 'Energy (keV)', 'Counts', 'blue')

# noise model needs some work prbably, Taking the avg of 10 models

added_sims = np.zeros(len(model))
for _ in range(10):
    noise = np.random.normal(loc=0, scale = 0.032, size= len(model_true))
    model_noisy = model * (1+ noise)
    added_sims = added_sims + model_noisy
avg_sims = added_sims/10

#-----------Plot of model smeared plot-----------------#

smeared_model_plot = plot_func(Energy_bin, model, 'Energy', 'Counts', 'Smeared Model', 'Energy (keV)', 'Counts', 'blue')
sir_peaks_plotalot(model, smeared_model_plot)
plt.show()

#----------- Differece plot-----------------#

difference = (model - data1_array)
avg_diff = np.mean(difference)
std_diff = np.std(difference)
std_diff_array = (difference - avg_diff) / std_diff

Smeared_model_std_plot = plot_func(Energy_bin, std_diff_array, 'Energy', 'Standard Deviation', 'Difference Between Model and Actual Data', 'Energy (keV)', 'Standard Deviation (Ïƒ)', 'blue')
plt.show()

#-------------------- Difference Histogram ----------------#

simulations = int(input("How many simulations?"))

tot_std_diff_array = np.zeros(len(Energy_bin))

for j in range(simulations):
    just_peaks = peak_inserter(model_true, left_ips, right_ips, peaks_raw_spec, width, data1_array, width_heights)
    model = np.maximum(just_peaks, smoothed)
    difference = (model - data1_array)
    avg_diff = np.mean(difference)
    std_diff = np.std(difference)
    std_diff_array = (difference - avg_diff) / std_diff
    count_num = np.linspace( std_diff_array.min(), std_diff_array.max(), (len(Energy_bin)+1))
    counts, bins = np.histogram(std_diff_array, bins=count_num)
    tot_std_diff_array += counts

plt.figure(figsize=(8, 6))
plt.hist(bins[:-1], bins, weights = tot_std_diff_array)
plt.xlabel("Distance from Centerline")
plt.ylabel("Frequency")
plt.title("Histogram of Distance from Centerline")

bin_centers = 0.5 * (bins[:-1] + bins[1:])
popt, _ = optimize.curve_fit(gaussian, bin_centers, tot_std_diff_array, p0=[max(tot_std_diff_array),
                                np.mean(bin_centers), np.std(bin_centers)])
a, b, c = popt
x_fit =  np.linspace( std_diff_array.max(), std_diff_array.min(), len(Energy_bin))
y_fit = gaussian(x_fit, *popt)
plt.plot(x_fit, y_fit, 'r-', label=f'Fit: Amplitude={a:.2f}, Mean={b:.2e}, Std={c:.2f}')
plt.legend()
plt.show()

#------- Finding Peaks in difference plot -------#

sir_peaks_displayalot(data1_array, 'Base Model')

sir_peaks_displayalot(model_noisy, 'Smeared model')
